#pragma config(Sensor, in1,    ArmPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    GyroSensor,     sensorGyro)
#pragma config(Sensor, in3,    CLAWW,          sensorPotentiometer)
#pragma config(Sensor, in4,    xAxis,          sensorAccelerometer)
#pragma config(Sensor, in5,    yAxis,          sensorAccelerometer)
#pragma config(Sensor, in6,    zAxis,          sensorAccelerometer)
#pragma config(Sensor, dgtl1,  frontRightEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  solenoid,       sensorDigitalOut)
#pragma config(Sensor, dgtl5,  solenoid2,      sensorDigitalOut)
#pragma config(Sensor, dgtl6,  frontLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  solenoid3,      sensorDigitalOut)
#pragma config(Sensor, dgtl11, Touch,          sensorTouch)
#pragma config(Motor,  port1,           lift1,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           r1,            tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port3,           r2,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           lift2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lift3,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lift4,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lift5,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           L2,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           L1,            tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port10,          lift6,         tmotorVex393_HBridge, openLoop)
#pragma config(DatalogSeries, 0, "Right Drive motor", Motors, MotorRunState, port2, 50)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#define bPlayMusicDuringMatch 1 //should music be played (1=yes, 0=no)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                              //
//	\\		//				 //\\				\\          //		||||		||||||||||||		|||||||||                             //
//	 \\	 //					//  \\			 \\        //     ||||		||              ||     ||                             //
//		\\//				 //||||\\				\\      //							||||||||||||    ||     ||                             //
//		//\\				// 			\\			 \\		 //				 ||			||              |||||||||                             //
//	 //	 \\			 //			   \\				\\  //         ||			||              ||      \\                            //
//	//		\\		//				  \\			 \\//          ||	 	  ||||||||||||    ||       \\                           //
//                                                                                                              //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// MAIN PROGRAM DESCRIPTIONS
// -------------------------
// This Version of Code is designed to be co-compatible with both Vex 0.5 and Vex Cortex (2.0)
// micro-controllers. All the loading is done automatically when you choose which platform you want in the menu.


// PROGRAM NOTES
// -------------
// NOTE: All bugs should be fixed in Version 1.7
// NOTE: This program referances other programs, these programs need to be referanced with in this file, and
//       all files must be in the same folder.

// PROGRAM VERSION
// ---------------
// Version: 3.0.1 "Norbit"
//		-Added new file systems. Restructured all file systems and organized code significantly.
//		 Introduced background code
//		-Added new auton funtions+lcd



// BACKAROUND CODE: Main competition background code...do not modify unless you know what you are doing!!!!
//#include "Vex_Competition_Includes.c"
//  OR:
//#include "StarStruckIncludes.c"

#include "StarStruckIncludes.c"

//Define encoder counts per revolution depending on motor
//This is helpful when programing Auton or Programing skills
#define MOTOR_TPR_269           240.448
#define MOTOR_TPR_393R          261.333
#define MOTOR_TPR_393S          392
#define MOTOR_TPR_393T          627.2
#define MOTOR_TPR_QUAD          360.0


// Constants for ChassisDrive-(Function to move & lift during Auton or Programming Skills.
const int Forwards = 1;
const int Backwards = 2;
const int TurnRight = 3;
const int TurnLeft = 4;
const int SweepRight = 5;
const int SweepLeft = 6;
const int BackSweepRight = 7;
const int BackSweepLeft = 8;
const int ForwardRight = 9;
const int ForwardLeft = 10;

//Constants for lift
const int down =1;
const int deploy=500;
const int up=1800;

// ********************  Gyro & lift Constants   **********************************
// Add new constants used by Gyro functions
const int Turn = 11;  // Used with Gyro senor
const int Sweep = 12; // Used with Gyro senor
const int GyroError = 120;  // Used to make Gyro turns more accurate by stopping before endpoint
const int LiftError = 50; // Used to make lift more accurate by stopping before endpoint

// PROGRAM NOTE
//      GyroError is used to define the period of time between the robot stoping and the distance it travels
//      while it is drifting until it comes to a complete stop. This is due to the (Fast)Speed of the chasis
//      stoping at the desired endpoint but the momentum of the robot keeps it moving(Turning). This is
//      eliminated using the GyroError and helps with accuracy



void liftMotors ( int speed)
{

	motor[lift1]= speed;
	motor[lift2]= speed;
	motor[lift3]= speed;
	motor[lift4]= speed;//sets lift speeds in Chasis functions for lifting but also driver
	motor[lift5]= speed;
	motor[lift6]= speed;

}



// ****************  END NEW CODE   **********************************
void chassisDrive (int leftSpeed, int rightSpeed)
{
	motor[L1]=leftSpeed;
	motor[r1]=rightSpeed; //sets drive speeds in Chasis functions for lifting but also driver
	motor[L2]=leftSpeed;
	motor[r2]=rightSpeed;

}







// Function to determine whether to keep going or not.
// Assumption is endValue is always positive so convert currentValue to positive too
bool shouldWeKeepGoing(int currentValue, int endValue)
{
	bool shouldGo = true;

	if (abs(currentValue) >= abs(endValue))
	{
		shouldGo = false;
	}
	return shouldGo;

}

// ********************  NEW CODE   **********************************
// Function to determine whether to keep going or not when using GYRO.
// Positive/negative values are very important with gyro
// Can't use ABS (Absolute values)
// With right turns we will pass currentValue, endValue
// With left turns we will pass endValue, currentValue
bool shouldWeKeepGoingGyro(int currentValue, int endValue)
{
	bool shouldGo = true;

	if (currentValue >= endValue)
	{
		shouldGo = false;
	}
	return shouldGo;
}
// ****************  END NEW CODE   **********************************

// Function to control chassis motors



////////////////////////////////////////////////////////////////////////////////////////////////////////////////







///////////////////////////////////////////////////////////////////////////////////////////////////////////////



// Function to move robot in specific directions
void robotFunction(int chassisDirection=0, int chassisSpeed=0, int chassisDistance=0,int liftHeight=0,int WaitTime=150,int clawo,int clawc, int LiftHoldSpeed=10, int DeploySolenoid=0)
{
	//********************(Clear Encoders)****************************
	SensorValue[frontRightEncoder] = 0;
	SensorValue[frontLeftEncoder]  = 0;
	//****************************************************************
	int shouldopen= 1200;
	// Define local variables
	bool isLiftMoving = false;
	//	int isWristMoving = 0;
	int leftSpeed = 0;
	int liftSpeed = 0;
	int rightSpeed = 0; // speed of motors for right side of chassis - is backward
	bool isChassisMoving = false; // Flag to determine if chassis moving routine should run

	int isRobotFunctionRunning = true; // Flag to determine if while loop should continue running
	// ********************  NEW CODE   **********************************
	int currentHeading = 0; // Gyro value of current heading
	// ****************  END NEW CODE   **********************************

	// Determine speeds of left and right side of robot
	switch (chassisDirection)
	{
	case Forwards:
		leftSpeed = chassisSpeed;
		rightSpeed = chassisSpeed;
		displayLCDString( 0,0, "Forward         ");
		displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[frontLeftEncoder]);
		break;
	case Backwards:
		leftSpeed = -chassisSpeed;
		rightSpeed = -chassisSpeed;
		displayLCDString(0, 0, "Backward        ");
			displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[frontLeftEncoder]);
		break;
	case TurnRight:
		leftSpeed = chassisSpeed;
		rightSpeed = -chassisSpeed;
		displayLCDString(0, 0, "TurnRight       ");
			displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[frontLeftEncoder]);
		break;
	case TurnLeft:
		leftSpeed = -chassisSpeed;
		rightSpeed = chassisSpeed;
		displayLCDString(0, 0, "TurnLeft        ");
			displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[frontLeftEncoder]);
		break;
	case SweepRight:
		leftSpeed = chassisSpeed;
		rightSpeed = 0;
		displayLCDString(0, 0, "SweepRight      ");
			displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[frontLeftEncoder]);
		break;
	case SweepLeft:
		leftSpeed = 0;
		rightSpeed = chassisSpeed;
		displayLCDString(0, 0, "SweepLeft       ");
			displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[frontRightEncoder]);
		break;
	case BackSweepRight:
		leftSpeed = 0;
		rightSpeed = -chassisSpeed;
		displayLCDString(0, 0, "BackSweepRight  ");
			displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[frontRightEncoder]);
		break;
	case BackSweepLeft:
		leftSpeed = -chassisSpeed;
		rightSpeed = 0;
		displayLCDString(0, 0, "BackSweepLeft   ");
			displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[frontLeftEncoder]);
		break;
	case ForwardRight:
		leftSpeed = chassisSpeed;
		rightSpeed = chassisSpeed*0.75;
		displayLCDString(0, 0, "ForwardRight    ");
			displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[frontLeftEncoder]);
		break;
	case ForwardLeft:
		leftSpeed = chassisSpeed*0.75;
		rightSpeed = chassisSpeed;
		displayLCDString(0, 0, "ForwardLeft     ");
			displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[frontLeftEncoder]);
		break;
		// ********************  NEW CODE   **********************************
		// Turn uses Gyro.
		// ChassisDistance will be the heading to turn to
		// GyroError helps make turns more accurate by using drift to finish turn
	case Turn:
		currentHeading = SensorValue[GyroSensor];   // Get current heading from gyro
		if (currentHeading + GyroError < chassisDistance) // Should we go right?
		{
			// Need to go to the right to reach destination
			leftSpeed = chassisSpeed;
			rightSpeed =-chassisSpeed;
			displayLCDString(0, 0, "Gyro Right Turn ");
				displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[GyroSensor]);
		} else if (currentHeading - GyroError > chassisDistance) // Should we go left?
		{
			// Need to go to the left to reach destination
			leftSpeed = -chassisSpeed;
			rightSpeed = chassisSpeed;
			displayLCDString(0, 0, "Gyro Left Turn  ");
				displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[GyroSensor]);
		} else // else already within the Error value of the direction. Don't move
		{
			leftSpeed = 0;
			rightSpeed = 0;
			chassisDirection = 0;
			displayLCDString(0, 0, "Gyro Nothing    ");
		}
		break;
	case Sweep:
		currentHeading = SensorValue[GyroSensor]; // Get current heading from gyro
		if (currentHeading + GyroError < chassisDistance) // Should we go right?
		{
			// Need to go to the right to reach destination
			leftSpeed = chassisSpeed;
			rightSpeed = 0;
			displayLCDString(0, 0, "Gyro Right Sweep Turn ");
				displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[GyroSensor]);
		} else if (currentHeading - GyroError > chassisDistance) // Should we go left?
		{
			// Need to go to the left to reach destination
			leftSpeed = 0;
			rightSpeed = chassisSpeed;
			displayLCDString(0, 0, "Gyro Left Sweep Turn  ");
				displayLCDNumber(1,1,chassisDistance);
			displayLCDNumber(1,10,SensorValue[GyroSensor]);
		} else // else already within the Error value of the direction. Don't move
		{
			leftSpeed = 0;
			rightSpeed = 0;
			chassisDirection = 0;
			displayLCDString(1, 0, "Gyro Nothing    ");


		}
		break;






		// ****************  END NEW CODE   **********************************
	default:
		leftSpeed = 0;
		rightSpeed = 0;
		displayLCDString(1, 0, "InvalidDirection");
		chassisDistance = 0;
	} // End Switch(chassisDirection)



	//determine liftspeeds

	if (SensorValue[ArmPot] < liftHeight-LiftError && liftHeight !=0)
	{
		liftSpeed =127;
		isLiftMoving = true;
		displayLCDNumber(0,0,SensorValue[ArmPot],10);
	}
	else if (SensorValue[ArmPot] > liftHeight+LiftError && liftHeight != 0)
	{
		liftSpeed =-127;
		isLiftMoving = true;
			displayLCDNumber(0,0,SensorValue[ArmPot],10);
	}
	else
	{
		liftSpeed = LiftHoldSpeed;
		isLiftMoving = false;
			displayLCDNumber(0,0,SensorValue[ArmPot],10);
	}

	if (SensorValue[CLAWW] > shouldopen)
	{
		SensorValue[solenoid] = clawo;
		SensorValue[solenoid2] = clawo;
	}
	else
	{
		SensorValue[solenoid] = clawc;
		SensorValue[solenoid2] = clawc;
	}

		SensorValue[solenoid3] = DeploySolenoid;

	// Check if robot is moving forward
	// ********************  NEW CODE   **********************************
	// Need to turn on isChassisMoving for Turns to heading 0
	//if (chassisDistance != 0)
	if (chassisDistance != 0 || chassisDirection == Turn || chassisDirection == Sweep)
		// ****************  END NEW CODE   **********************************
	{
		isChassisMoving = true;
		// ********************  NEW CODE   **********************************

		// ****************  END NEW CODE   **********************************
	}

	while(isRobotFunctionRunning)
	{
		if (isChassisMoving)
		{
			if (chassisDirection == SweepLeft || chassisDirection == BackSweepRight)
			{
				// Use rightEncoder because left motor is zero in these cases
				isChassisMoving = shouldWeKeepGoing(SensorValue[frontRightEncoder],chassisDistance);//current value , end value
			}
			// ********************  NEW CODE   **********************************
			// Add turn to While loop
			else if (chassisDirection == Turn ||chassisDirection == Sweep)
			{
				if (rightSpeed <= 0) // Indicates turning to the right. EndValue will be higher in this case
				{
					isChassisMoving = shouldWeKeepGoingGyro(SensorValue[GyroSensor] + GyroError,chassisDistance);
				} else // Indicates turning to the left. EndValue will be lower in this case
				{
					isChassisMoving = shouldWeKeepGoingGyro(chassisDistance,SensorValue[GyroSensor] - GyroError);
				}
			}
			// ****************  END NEW CODE   **********************************
			else {
				// Otherwise, use leftEGyroSensor
				isChassisMoving = shouldWeKeepGoing(SensorValue[frontLeftEncoder],chassisDistance);
			} // End of chassisDirection == SweepLeft...
		} else
		{
			leftSpeed = 0;
			rightSpeed = 0;
		} // End of is ChassisMoving

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		if(isLiftMoving)
		{
			if(liftSpeed > 0)
			{
				isLiftMoving = shouldWeKeepGoing(SensorValue[ArmPot], liftHeight-LiftError);


			}
			else
			{
				isLiftMoving = shouldWeKeepGoing(liftHeight+LiftError, SensorValue[ArmPot]);
			}
		}
		else
		{
			liftSpeed = 10;
		} //End of is LiftMoving
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		chassisDrive(rightSpeed, leftSpeed); // Set chassis motors one time
		liftMotors (liftSpeed);
		isRobotFunctionRunning = isChassisMoving + isLiftMoving;// + isWristMoving; // Should while loop continue?
	}  // End of While loop
	chassisDrive(0, 0); // Stop the robot
	liftMotors (10);



	wait1Msec(WaitTime);
} // End robotFunction















// Test of all chassisDirections
void testChassisDirections()
{


	//robotFunction (Forwards,127,600);

	//robotFunction (Backwards, 127, 600);

	//robotFunction (TurnRight,127,275);

	//robotFunction (TurnLeft,127,275);

	//robotFunction (SweepRight,127,275);

	//robotFunction (SweepLeft,127,275);

	//robotFunction (BackSweepRight,127,275);

	//robotFunction (BackSweepLeft,127,275);

	//robotFunction (ForwardLeft,127,275);

	//robotFunction (ForwardRight,127,275);
	//robotFunction(Forward, 127,900);
	//robotFunction(Backward, 127, 900);
	//robotFunction(TurnLeft, 127, 400);  // Out of order
	//robotFunction(TurnRight, 127, 400); // Out of order - Right first hits the bump

	//// ********************  NEW CODE   **********************************
	//robotFunction(Turn, 127, 1800); // Test Gyro Turn to 90 degress
	//robotFunction(Turn, 127, 900); 	// Test Gyro Turn to 180 degress
	//robotFunction(Turn, 127, 0); 		// Test Gyro Turn to 0 degress
	//robotFunction(Turn, 127, -1800);// Test Gyro Turn to -180 degress
	//robotFunction(Turn, 127, -900); // Test Gyro Turn to -90 degress
	//robotFunction(Turn, 127, 0); 		// Test Gyro Turn to 0 degress
	//robotFunction(Turn, 127, 0); 		// Test Gyro Nothin Turn

	//robotFunction(Sweep, 127, 1800); // Test Gyro Sweep Turn to 90 degress
	//robotFunction(Sweep, 127, 900); 	// Test Gyro Sweep Turn to 180 degress
	//robotFunction(Sweep, 127, 0); 		// Test Gyro Sweep Turn to 0 degress
	//robotFunction(Sweep, 127, -1800);// Test Gyro Sweep Turn to -180 degress
	//robotFunction(Sweep, 127, -900); // Test Gyro Sweep Turn to -90 degress
	//robotFunction(Sweep, 127, 0); 		// Test Gyro Sweep Turn to 0 degress
	//robotFunction(Sweep, 127, 0); 		// Test Gyro Nothin Turn

	//// ****************  END NEW CODE   **********************************

	//robotFunction(SweepRight, 127, 900);
	//robotFunction(SweepLeft, 127, 900);
	//robotFunction(BackSweepRight, 127, 900);
	//robotFunction(BackSweepLeft, 127, 900);
	//robotFunction(ForwardRight, 127, 900);
	//robotFunction(ForwardLeft, 127, 900);
	//robotFunction(0,127, 900);
}


//autonomous 1 ()//left side cube+4 stars
//autonomous 2 ()//right side cube+4 stars
//autonomous 3 ()//left side 2 stars
//autonomous 4 ()//right side 2 stars
//autonomous 5 () //block from left square
//autonomous ()//skills//         //new skills tht may actually work?
//autonomous 7 ()//1st skils?-Backup !!commented out!!-will not run
//autonomous 8 ()//left side 2 stars?-Backup !!commented out!!-will not run
// autonomous ()//right side 2 stars?-Backup !!commented out!!-will not run


//autonomous 10 ()
////10-14  currently empty, select these during inspection so the robot won't drive off the table, or when no auton is desired
//autonomous 14 ()


void autonomous1 ()//left side cube+4 stars   encoder *2.56
{
	robotFunction(Forwards, 127, 0,250,0,1,1,0,1);//lift up open claw
	robotFunction(Forwards, 0, 0,1,0,0,0,-5);
	robotFunction(Forwards, 127, 1536,1,0,1,1,-5);//lift down close claw wait 500
	//robotFunction(Forwards,127,1536,1,0,1,1);//forward 1000, lift 0, wait 0, open claw

	robotFunction(Forwards, 0, 0,1,150,0,0);// close claw + wait 300(changed to 150)(may need to be reverted)
	robotFunction(Forwards, -127, 614,800,0,0,0);// backup 400, lift 800, wait 0, close claw
	robotFunction(Sweep, 127,-1100,800,0,0,0);//gyro turn to -1100, lift 800, claw closed
	robotFunction(Forwards,-127,1433,800,0,0,0);//backwards 1100, lift 800, wait 150, claw closed
	robotFunction(Forwards, 0, 0,up,0,1,0);//lift up, wait 150, open claw midway
	robotFunction(Forwards, 0, 0,1,0,1,1);//realign-tchnically, turn to ____,lift down(0), open claw/////////////////////////add gyro count that aligns with perimeter wall/////////////
	robotFunction(Forwards,127,998,1,300,1,1);//forwards 650,llift down,wait 300, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1383,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300
}




void autonomous2 ()//right side cube+4 stars
{
	robotFunction(Forwards, 127, 0,250,0,1,1,0,1);//lift up open claw
	robotFunction(Forwards, 0, 0,1,0,0,0,-5);
	robotFunction(Forwards, 127, 1536,1,0,1,1,-5);//lift down close claw wait 500
	//robotFunction(Forwards,127,1536,1,0,1,1);//forward 1000, lift 0, wait 0, open claw

	robotFunction(Forwards, 0, 0,1,150,0,0);// close claw + wait 300(changed to 150)(may need to be reverted)
	robotFunction(Forwards, -127, 614,800,0,0,0);// backup 400, lift 800, wait 0, close claw
	robotFunction(Sweep, 127,1100,800,0,0,0);//gyro turn to -1100, lift 800, claw closed
	robotFunction(Forwards,-127,1433,800,0,0,0);//backwards 1100, lift 800, wait 150, claw closed
	robotFunction(Forwards, 0, 0,up,0,1,0);//lift up, wait 150, open claw midway
	robotFunction(Forwards, 0, 0,1,0,1,1);//realign-tchnically, turn to ____,lift down(0), open claw/////////////////////////add gyro count that aligns with perimeter wall/////////////
	robotFunction(Forwards,127,998,1,300,1,1);//forwards 650,llift down,wait 300, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1383,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300
}
void autonomous3 ()//left side 2 stars ---needs work/love !!reminder!! ---muliply encoder value by .6
{
		wait1Msec(5000);
	robotFunction (Forwards,-127,768,0,0,0,0);//backwards
	//robotFunction(Forwards, 0, 0,deploy,500,1,1);//lift up open claw
	robotFunction(Forwards, 127, 0,250,0,1,1,0,1);//lift up open claw
	robotFunction(Forwards, 0, 0,1,500,0,0);//lift down close claw wait 500
	robotFunction(Forwards,127,998,1,150,1,1);//forward 1000, lift 0, wait 0, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw
	robotFunction(Forwards,-127,384,900,150,0,0);//backwards
	robotFunction(Turn, 127,780,950,150,0,0);
	robotFunction(Forwards,-127,1536,950,150,0,0);
	robotFunction(Forwards, 0, 0,up,0,0,1);//lift up, wait 150, open claw midway

			robotFunction(Forwards, 0, 0,1,0,1,1);//realign-tchnically, turn to ____,lift down(0), open claw/////////////////////////add gyro count that aligns with perimeter wall/////////////
	robotFunction(Forwards,127,998,1,300,1,1);//forwards 650,llift down,wait 300, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1383,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300
			robotFunction(Forwards, 0, 0,1,0,1,1);//realign-tchnically, turn to ____,lift down(0), open claw/////////////////////////add gyro count that aligns with perimeter wall/////////////
	robotFunction(Forwards,127,998,1,300,1,1);//forwards 650,llift down,wait 300, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1383,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300

}
void autonomous4 ()//right side 2 stars  ---needs work/love !!reminder!! ---muliply encoder value by .6
{
		wait1Msec(5000);
	robotFunction (Forwards,-127,768,0,0,0,0);//backwards
	//robotFunction(Forwards, 0, 0,deploy,500,1,1);//lift up open claw
	robotFunction(Forwards, 127, 0,250,0,1,1,0,1);//lift up open claw
	robotFunction(Forwards, 0, 0,1,500,0,0);//lift down close claw wait 500
	robotFunction(Forwards,127,998,1,150,1,1);//forward 1000, lift 0, wait 0, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw
	robotFunction(Forwards,-127,384,900,150,0,0);//backwards
	robotFunction(Turn, 127,-780,950,150,0,0);
	robotFunction(Forwards,-127,1536,950,150,0,0);
	robotFunction(Forwards, 0, 0,up,0,0,1);//lift up, wait 150, open claw midway

			robotFunction(Forwards, 0, 0,1,0,1,1);//realign-tchnically, turn to ____,lift down(0), open claw/////////////////////////add gyro count that aligns with perimeter wall/////////////
	robotFunction(Forwards,127,998,1,300,1,1);//forwards 650,llift down,wait 300, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1383,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300
			robotFunction(Forwards, 0, 0,1,0,1,1);//realign-tchnically, turn to ____,lift down(0), open claw/////////////////////////add gyro count that aligns with perimeter wall/////////////
	robotFunction(Forwards,127,998,1,300,1,1);//forwards 650,llift down,wait 300, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1383,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300

}
void autonomous5 () //block from left square  ---needs work/love !!TEST!!!!!!!!
{

	robotFunction(Forwards, 127, 600,250,0,1,1,0,1);//lift up open claw
//	robotFunction(Forwards, 0, 0,deploy,300,1,1);//lift up open claw
//	robotFunction(Forwards, 0, 0,down,0,1,1);//lift down close claw wait 500
	robotFunction(Forwards,127,998,500,0,1,1);
	robotFunction(Sweep, 127,300,500,0,1,1);
	robotFunction(Forwards,127,640,1000,0,1,1);

}

void autonomous6 ()//skills//         //new skills tht may actually work?  ---needs work/love
{
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//first delpoy + dump
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////v///////////////////////
	robotFunction(Forwards, -127, 614,0,150,0,0);//back up 400  !!Warning!! this may not hit the target liftheigt, if it does not, chage value for lift!!
	//robotFunction(Forwards, 0, 0,deploy,500,1,1);// lift up 500, open claw
	robotFunction(Forwards, 127, 0,250,0,1,1,0,1);//lift up open claw
	robotFunction(Forwards, 0, 0,down,150,1,1); //down lift,
	robotFunction (Forwards,127,461,down,150,1,1);////////////////////////forwards to load
	wait1Msec(500);//wait to load
	robotFunction(Forwards, -127, 1536, 600,0,0,0);//backup
	robotFunction(Forwards, 0, 0, up,150,0,1);//lift +claw DUUMPP
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//second dump
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	robotFunction(Turn, 127, 0, 200,150,1,1);//------// turn to zero, lift 200
	robotFunction(Forwards, 127, 1075, 600,150,1,1);////forward, open claw
	wait1Msec(500);//wait to load
	robotFunction(Forwards, 0, 0,600,150,0,0);//close claw
	robotFunction(Forwards, -127, 1075, 600,150,0,0);//backup 700, lift 300
	robotFunction(Forwards, 0, 0, up,150,0,1);//up+open claw
	wait1Msec(500);
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//third dump
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		robotFunction(Turn, 127, 0, 200,150,1,1);//------// turn to zero, lift 200
	robotFunction(Forwards, 127, 1075, 600,150,1,1);////forward, open claw
	wait1Msec(500);//wait to load
	robotFunction(Forwards, 0, 0,600,150,0,0);//close claw
	robotFunction(Forwards, -127, 1075, 600,150,0,0);//backup 700, lift 300
	robotFunction(Forwards, 0, 0, up,150,0,1);//up+open claw
	wait1Msec(500);
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//4th dump
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//robotFunction(Turn, 127, 0, 200,150,1,1);//------// turn to zero, lift 200
	//robotFunction(Forwards, 127, 1075, 600,150,1,1);////forward, open claw
	//wait1Msec(500);//wait to load
	//robotFunction(Forwards, 0, 0,600,150,0,0);//close claw
	//robotFunction(Forwards, -127, 1075, 600,150,0,0);//backup 700, lift 300
	//robotFunction(Forwards, 0, 0, up,150,0,1);//up+open claw
	//wait1Msec(500);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//turn grab 3 stars +cube and dump
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	robotFunction(Turn,127, 800, 500, 150,0,0);//////////////

	robotFunction(Forwards, -127, 768,500,150,0,0);
	robotFunction(Forwards, 127, 1536,down,500,1,1);
	robotFunction(Forwards, 0, 0,down,0,0,0);
	wait1Msec(500);
	robotFunction(Turn, 63, 50, 600,150,0,0);
	robotFunction(Forwards,- 127, 461,600,150,1,1);
	//		robotFunction(Forwards, 0, 0,0,1,1);
	robotFunction(Forwards, 0, 0, up,150,0,1);
		robotFunction(Forwards, 0, 0,down,0,1,1);
			robotFunction(Forwards,127,900,1,300,1,1);//forwards 650,llift down,wait 300, open claw
				robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1200,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300

}
void autonomous7 ()//1st skils?
{
	robotFunction(Forwards, 127, 0,250,0,1,1,0,1);//lift up open claw
	robotFunction(Forwards, 0, 0,1,0,0,0,-5);
	robotFunction(Forwards, 127, 1536,1,0,1,1,-5);//lift down close claw wait 500
	//robotFunction(Forwards,127,1536,1,0,1,1);//forward 1000, lift 0, wait 0, open claw

	robotFunction(Forwards, 0, 0,1,150,0,0);// close claw + wait 300(changed to 150)(may need to be reverted)
	robotFunction(Forwards, -127, 614,800,0,0,0);// backup 400, lift 800, wait 0, close claw
	robotFunction(Sweep, 127,-1100,800,0,0,0);//gyro turn to -1100, lift 800, claw closed
	robotFunction(Forwards,-127,1433,800,0,0,0);//backwards 1100, lift 800, wait 150, claw closed
	robotFunction(Forwards, 0, 0,up,0,1,0);//lift up, wait 150, open claw midway
	robotFunction(Forwards, 0, 0,1,0,1,1,-5);//realign-tchnically, turn to ____,lift down(0), open claw/////////////////////////add gyro count that aligns with perimeter wall/////////////
	robotFunction(Forwards,127,998,1,300,1,1,-5);//forwards 650,llift down,wait 300, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1383,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300
		robotFunction(Forwards, 0, 0,1,0,1,1,-5);//realign-tchnically, turn to ____,lift down(0), open claw/////////////////////////add gyro count that aligns with perimeter wall/////////////
	robotFunction(Forwards,127,998,1,300,1,1,-5);//forwards 650,llift down,wait 300, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1383,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300

}
void autonomous8 ()//left side 2 stars?
{
	robotFunction(Forwards, 127, 0,250,0,1,1,0,1);//lift up open claw
	robotFunction(Forwards, 0, 0,1,0,0,0,-5);
	robotFunction(Forwards, 127, 1536,1,0,1,1,-5);//lift down close claw wait 500
	//robotFunction(Forwards,127,1536,1,0,1,1);//forward 1000, lift 0, wait 0, open claw

	robotFunction(Forwards, 0, 0,1,150,0,0);// close claw + wait 300(changed to 150)(may need to be reverted)
	robotFunction(Forwards, -127, 614,800,0,0,0);// backup 400, lift 800, wait 0, close claw
	robotFunction(Sweep, 127,1100,800,0,0,0);//gyro turn to -1100, lift 800, claw closed
	robotFunction(Forwards,-127,1433,800,0,0,0);//backwards 1100, lift 800, wait 150, claw closed
	robotFunction(Forwards, 0, 0,up,0,1,0);//lift up, wait 150, open claw midway
	robotFunction(Forwards, 0, 0,1,0,1,1,-5);//realign-tchnically, turn to ____,lift down(0), open claw/////////////////////////add gyro count that aligns with perimeter wall/////////////
	robotFunction(Forwards,127,998,1,300,1,1,-5);//forwards 650,llift down,wait 300, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1383,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300
		robotFunction(Forwards, 0, 0,1,0,1,1,-5);//realign-tchnically, turn to ____,lift down(0), open claw/////////////////////////add gyro count that aligns with perimeter wall/////////////
	robotFunction(Forwards,127,998,1,300,1,1,-5);//forwards 650,llift down,wait 300, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1383,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300
}
void autonomous9 ()//right side 2 stars?
{
	//robotFunction(Forwards, 0, 0,deploy,100,1,1);
	//robotFunction(Forwards, 0, 0,0,150,0,0);
	//robotFunction (Forwards,127,1000,0,150,1,1);
	//robotFunction(Forwards, 0, 0,0,150,0,0);
	//robotFunction(Forwards, -127, 600,800);
	//robotFunction(Sweep, 127,1100,900);
	//robotFunction (Forwards,-127,1100,1000);
	//robotFunction(Forwards, 0, 0,up,150,1,0);
}
void autonomous10 ()
{

}
void autonomous11 ()
{

}
void autonomous12 ()
{
}
void autonomous13 ()
{
	testChassisDirections();
}
void autonomous14 ()
{

robotFunction (Forwards,-127,768,0,0,0,0);//backwards
	//robotFunction(Forwards, 0, 0,deploy,500,1,1);//lift up open claw
	robotFunction(Forwards, 127, 0,250,0,1,1,0,1);//lift up open claw
	robotFunction(Forwards, 0, 0,1,500,0,0);//lift down close claw wait 500
	robotFunction(Forwards,127,998,1,150,1,1);//forward 1000, lift 0, wait 0, open claw
	robotFunction(Forwards, 0, 0,1,300,0,0);//close claw
	robotFunction(Forwards,-127,384,900,150,0,0);//backwards
	robotFunction(Turn, 127,780,950,150,0,0);
	robotFunction(Forwards,-127,1536,950,150,0,0);
	robotFunction(Forwards, 0, 0,up,0,0,1);//lift up, wait 150, open claw midway


		robotFunction(Forwards, 127, 1075, 600,150,1,1);////forward, open claw
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//first delpoy + dump
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////v///////////////////////
	//robotFunction(Forwards, -127, 614,0,150,0,0);//back up 400  !!Warning!! this may not hit the target liftheigt, if it does not, chage value for lift!!
	////robotFunction(Forwards, 0, 0,deploy,500,1,1);// lift up 500, open claw
	//robotFunction(Forwards, 127, 0,250,0,1,1,0,1);//lift up open claw
	//robotFunction(Forwards, 0, 0,down,150,1,1); //down lift,
	//robotFunction (Forwards,127,461,down,150,1,1);////////////////////////forwards to load
	wait1Msec(500);//wait to load
	robotFunction(Forwards, -127, 1536, 600,0,0,0);//backup
	robotFunction(Forwards, 0, 0, up,150,0,1);//lift +claw DUUMPP
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//second dump
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	robotFunction(Turn, 127, 0, 200,150,1,1);//------// turn to zero, lift 200
	robotFunction(Forwards, 127, 1075, 600,150,1,1);////forward, open claw
	wait1Msec(500);//wait to load
	robotFunction(Forwards, 0, 0,600,150,0,0);//close claw
	robotFunction(Forwards, -127, 1075, 600,150,0,0);//backup 700, lift 300
	robotFunction(Forwards, 0, 0, up,150,0,1);//up+open claw
	wait1Msec(500);
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//third dump
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		robotFunction(Turn, 127, 0, 200,150,1,1);//------// turn to zero, lift 200
	robotFunction(Forwards, 127, 1075, 600,150,1,1);////forward, open claw
	wait1Msec(500);//wait to load
	robotFunction(Forwards, 0, 0,600,150,0,0);//close claw
	robotFunction(Forwards, -127, 1075, 600,150,0,0);//backup 700, lift 300
	robotFunction(Forwards, 0, 0, up,150,0,1);//up+open claw
	wait1Msec(500);
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//4th dump
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//robotFunction(Turn, 127, 0, 200,150,1,1);//------// turn to zero, lift 200
	//robotFunction(Forwards, 127, 1075, 600,150,1,1);////forward, open claw
	//wait1Msec(500);//wait to load
	//robotFunction(Forwards, 0, 0,600,150,0,0);//close claw
	//robotFunction(Forwards, -127, 1075, 600,150,0,0);//backup 700, lift 300
	//robotFunction(Forwards, 0, 0, up,150,0,1);//up+open claw
	//wait1Msec(500);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//turn grab 3 stars +cube and dump
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	robotFunction(Turn,127, 800, 500, 150,0,0);//////////////

	robotFunction(Forwards, -127, 768,500,150,0,0);
	robotFunction(Forwards, 127, 1536,down,500,1,1);
	robotFunction(Forwards, 0, 0,down,0,0,0);
	wait1Msec(500);
	robotFunction(Turn, 63, 50, 600,150,0,0);
	robotFunction(Forwards,- 127, 461,600,150,1,1);
	//		robotFunction(Forwards, 0, 0,0,1,1);
	robotFunction(Forwards, 0, 0, up,150,0,1);
		robotFunction(Forwards, 0, 0,down,0,1,1);
			robotFunction(Forwards,127,900,1,300,1,1);//forwards 650,llift down,wait 300, open claw
				robotFunction(Forwards, 0, 0,1,300,0,0);//close claw+wait 300
	robotFunction(Forwards,-127,1200,600,0,0,0);//backup 900, lift 600, claw closed
	robotFunction(Forwards, 0, 0,up,300,0,1);//lift up, open claw, wait 300


}
//////////////////////////////////////////////////////////////////////////////////////////////////
void pre_auton()
{
	bStopTasksBetweenModes = true;
	//startTask(autonomousSelection);  //starts auton selection
	// NOTE: Task auton selection was moved to background code
}
//////////////////////////////////////////////////////////////////////////////////////////////////

task autonomous()//defines autonoums selected
{
	if (autonomousMode == 1)
	{
		autonomous1();
	}
	else if (autonomousMode == 2)
	{
		autonomous2();
	}
	else if (autonomousMode == 3)
	{
		autonomous3();
	}
	else if (autonomousMode == 4)
	{
		autonomous4();
	}
	else if (autonomousMode == 5)
	{
		autonomous5();
	}
	else if (autonomousMode == 6)
	{
		autonomous6();
	}
	else if (autonomousMode == 7)
	{
		autonomous7();
	}
	else if (autonomousMode == 8)
	{
		autonomous8();
	}
	else if (autonomousMode == 9)
	{
		autonomous9();
	}
	else if (autonomousMode == 10)
	{
		autonomous10();
	}
	else if (autonomousMode == 11)
	{
		autonomous11();
	}
	else if (autonomousMode == 12)
	{
		autonomous12();
	}
	else if (autonomousMode == 13)
	{
		autonomous13();
	}
	else if (autonomousMode == 14)
	{
		autonomous14();
	}

}

//////////////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
//	startTask(driverControlViewValues);
	bool curve = true;  //drive function
	bool control = false; //drive function
	bool inversed = false; //drive function
	bLCDBacklight = true;	// Turn on LCD Backlight for visiblity
	string mainBattery;// displays battery voltage on lcd
	float LeftIn;//drive function
	float RightIn;//drive function

	while(true)
	{
		if(driverControlModeCount == 4 && nLCDButtons == 2)//starts auton in driver useful during
		{																									// practice
			startTask(autonomous);
			clearTimer(T2);
			displayLCDString(0, 0, "autonomous");
			displayLCDNumber(1,0,time1[T2],4);
			while(time1[T2] < 15000)
			{
				displayLCDString(0, 0, "autonomous");
				displayLCDNumber(1,0,time1[T2]);
			}
			stopTask(autonomous);
		}


		if (nVexRCReceiveState & vrXmit2)//if 2 controler
		{
			/////////////////////////////////////////////////////////////////////////////////


			//if(vexRT[Btn5UXmtr2] == 1)       	//If button 5U is pressed...
			//{

			//	motor[lift1]= 127;
			//	motor[lift2]= 127;
			//	motor[lift3]= 127;
			//	motor[lift4]= 127;//...raise the arm.
			//	motor[lift5]= 127;
			//	motor[lift6]= 127;
			//}
			//else if(vexRT[Btn5DXmtr2] == 1)  	//Else, if button 5D is pressed...
			//{
			//	motor[lift1]= -127;
			//	motor[lift2]= -127;
			//	motor[lift3]= -127;
			//	motor[lift4]=- 127;
			//	motor[lift5]= -127;
			//	motor[lift6]= -127;

			//}
			//else                      		//Else (neither button is pressed)...
			//{
			//	motor[lift1]= 0;
			//	motor[lift2]=0 ;
			//	motor[lift3]= 0;
			//	motor[lift4]= 0;
			//	motor[lift5]= 0;
			//	motor[lift6]= 0;
			//}

			//	motor[lift1]= vexRT[Ch3Xmtr2];
			motor[lift2]= vexRT[Ch3Xmtr2];
			motor[lift3]= vexRT[Ch3Xmtr2];
			motor[lift4]= vexRT[Ch3Xmtr2];//...raise the arm.
			motor[lift5]= vexRT[Ch3Xmtr2];
			motor[lift6]= vexRT[Ch3Xmtr2];


			if(vexRT[Btn6UXmtr2] == 1)         // If button 6U (upper right shoulder button) is pressed:
			{
				SensorValue[solenoid3] = 1;


				// ...activate the solenoid.
			}
			else                          // If button 6U (upper right shoulder button) is  NOT pressed:
			{
				SensorValue[solenoid3] = 0;

				;// ..deactivate the solenoid.
			}





			if(vexRT[Btn6DXmtr2] == 1)         // If button 6U (upper right shoulder button) is pressed:
			{
				SensorValue[solenoid] = 1;
				SensorValue[solenoid2] = 1;

				// ...activate the solenoid.
			}
			else                          // If button 6U (upper right shoulder button) is  NOT pressed:
			{
				SensorValue[solenoid] = 0;
				SensorValue[solenoid2] = 0;
				;// ..deactivate the solenoid.
			}



			if (curve)//parabloic curve
			{
				LeftIn=(vexRT[Ch3]*vexRT[Ch3])/127.0;
				RightIn=(vexRT[Ch2]*vexRT[Ch2])/127.0;
				if(vexRT[Ch3] < 0)
				{
					LeftIn=LeftIn*-1.0;
				}
				if(vexRT[Ch2] < 0)
				{
					RightIn=RightIn*-1.0;
				}
			}
			else
			{
				LeftIn=vexRT[Ch3];//regular drive
				RightIn=vexRT[Ch2];
			}

			if(control)
			{
				LeftIn=(vexRT[Ch3]/2);//drive speed cut in half for control
				RightIn=(vexRT[Ch2]/2);
			}

			if(!inversed)//drive inversed for hanging
			{
				chassisDrive(LeftIn,RightIn);
			}
			else
			{
				chassisDrive(-RightIn, -LeftIn,);
			}
			/////////////////////////////////////////////////////////////////////////////////


			if (vexRT[Btn7D]==1)//controls drive speeds shown above
			{
				curve=true;
			}
			if (vexRT[Btn7L]==1)
			{
				curve=false;
			}

			if(vexRT[Btn8R]==1)
			{
				control = true;
			}
			if(vexRT[Btn8D]==1)
			{
				control = false;
			}

			if(vexRT[Btn5U]==1)
			{
				inversed = false;
			}
			if(vexRT[Btn5D]==1)
			{
				inversed = true;
			}
		}



		else//else 1 controler
		{
			if (curve)//parabloic curve
			{
				LeftIn=(vexRT[Ch3]*vexRT[Ch3])/127.0;
				RightIn=(vexRT[Ch2]*vexRT[Ch2])/127.0;
				if(vexRT[Ch3] < 0)
				{
					LeftIn=LeftIn*-1.0;
				}
				if(vexRT[Ch2] < 0)
				{
					RightIn=RightIn*-1.0;
				}
			}
			else
			{
				LeftIn=vexRT[Ch3];//regular drive
				RightIn=vexRT[Ch2];
			}

			if(control)
			{
				LeftIn=(vexRT[Ch3]/2);
				RightIn=(vexRT[Ch2]/2);//drive speed cut in half for control
			}

			if(!inversed)//drive inversed for hanging
			{
				chassisDrive(LeftIn,RightIn);
			}
			else
			{
				chassisDrive(-RightIn, -LeftIn,);
			}
			/////////////////////////////////////////////////////////////////////////////////

			if(vexRT[Btn5U] == 1)       	//If button 5U is pressed...
			{
				//			motor[lift1]= 127;
				motor[lift2]= 127;
				motor[lift3]= 127;
				motor[lift4]= 127;//...raise the arm.
				motor[lift5]= 127;
				motor[lift6]= 127;
			}
			else if(vexRT[Btn5D] == 1)  	//Else, if button 5D is pressed...
			{
				//		motor[lift1]= -127;
				motor[lift2]= -127;
				motor[lift3]= -127;
				motor[lift4]=- 127;
				motor[lift5]=- 127;
				motor[lift6]= -127;

			}
			else                      		//Else (neither button is pressed)...
			{
				//			motor[lift1]= 0;
				motor[lift2]= 0;
				motor[lift3]= 0;
				motor[lift4]= 0;
				motor[lift5]= 0;
				motor[lift6]= 0;
			}


			if(vexRT[Btn6U] == 1)         // If button 6U (upper right shoulder button) is pressed:
			{
				SensorValue[solenoid3] = 1;


				// ...activate the solenoid.
			}
			else                          // If button 6U (upper right shoulder button) is  NOT pressed:
			{
				SensorValue[solenoid3] = 0;

			// ..deactivate the solenoid.
			}



			if(vexRT[Btn6D] == 1)         // If button 6U (upper right shoulder button) is pressed:
			{
				SensorValue[solenoid] = 1;
				SensorValue[solenoid2] = 1;

				// ...activate the solenoid.
			}
			else                          // If button 6U (upper right shoulder button) is  NOT pressed:
			{
				SensorValue[solenoid] = 0;
				SensorValue[solenoid2] = 0;
				;// ..deactivate the solenoid.
			}


			if (vexRT[Btn7D]==1)
			{
				curve=true;
			}
			if (vexRT[Btn7L]==1)
			{
				curve=false;
			}

			if(vexRT[Btn8R]==1)
			{
				control = true;
			}
			if(vexRT[Btn8D]==1)
			{
				control = false;
			}

			if(vexRT[Btn8U]==1)
			{
				inversed = false;
			}
			if(vexRT[Btn7U]==1)
			{
				inversed = true;
			}
			/////////////////////////////////////////////////////////////////////////////////




		}
		/////////////////////////////////
	}
}
